/**
 * Aaron Li
 * 113319376
 * aaron.li@stonybrook.edu
 * Assignment 5
 * CSE214
 * REC02 - Felix Rieg-Baumhauer
 */
/**
 * This is the StoryTree class
 * StoryTreeNode root is the root node of the tree
 * StoryTreeNode cursor is the pointer for traversing the tree
 * GameState state is an enum representing the state of the game
 * This tree will represent a story
 */
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;
public class StoryTree {
    StoryTreeNode root;
    StoryTreeNode cursor;
    GameState state;
    String text = "";
    boolean check = false;
    public static double count = 0.0;
    public static double win = 0.0;
    public enum GameState{
        GAME_OVER_WIN,
        GAME_OVER_LOSE,
        GAME_NOT_OVER
    }

    /**
     * Default constructor for StoryTree
     * creates StoryTreeNode root
     * sets GameState state to GAME_NOT_OVER
     * sets cursor to point at the root
     */
    public StoryTree(){
        this.root = new StoryTreeNode("root", "root", "Hello, Welcome to Zork!");
        this.cursor = root;
        this.state = GameState.GAME_NOT_OVER;
    }

    /**
     * Reads in a text file describing a StoryTree
     * @param filename
     * name of file to read from
     * Precondition:
     * filename is not null, non-empty String that points to a file that exists that is readable, and is valid
     * @return
     * A new StoryTree generated by the passed in text file is returned
     * @exception
     * throws IllegalArgumentException if filename is empty or null
     * throws DataFormatException if the file contains inconsistent format
     */
    public StoryTree readTree(String filename){
        String temp, position = "", option = "", message = "";
        String[] info;
        StoryTree story = new StoryTree();
        try {
            File text = new File("D:\\Stony\\CSE214\\CSE214_Homework_5\\src", filename);
            Scanner fileIn = new Scanner(text);
            while(fileIn.hasNextLine()) {
                int count = 0;
                temp = fileIn.nextLine();
                for(int i =0; i < temp.length();i++) {
                    if (temp.charAt(i)=='|')
                        count++;
                }
                //if(count != 3)
                    //throw new DataFormatException("Error. File contains invalid format.");
                info = temp.split(" \\| ");
                position = info[0];
                option = info[1];
                message = info[2];
                addChild(position, option, message);
            }
            fileIn.close();
        } catch (FileNotFoundException fnfe) {
            System.out.println("An error occured.");
        }
        //catch(DataFormatException e){
            //System.out.println(e.getMessage());
        //}
        return story;
    }

    /**
     * Saves a StoryTree to the indicated file which is same as input
     * @param filename
     * name of the file read from
     * @param tree
     * A reference to the tree to save to the indicated file
     * Precondition:
     * tree is not null
     * filename is a non-null, non-empty String
     * @exception
     * throws IllegalArgumentException if filename empty or null or tree is null
     */
    public void saveTree(String filename, StoryTree tree){
        StoryTreeNode temp = tree.root.getLeftChild();
        savePrint(temp);
        File dir = new File("D:\\Stony\\CSE214\\CSE214_Homework_5\\src", filename);
        try {
            PrintWriter fileOut = new PrintWriter(dir);
            fileOut.println(text);
            fileOut.close();
        } catch (FileNotFoundException fnfe) {
            System.out.println("An error occured.");
        }
    }

    /**
     * This will traverse through
     * @param node
     * starting node
     * Precondition:
     * node is the root of the tree
     */
    public void savePrint(StoryTreeNode node){
        if(check)
            text += "\n";
        text += node.getPosition() + " | " + node.getOption() + " | " + node.getMessage();
        check = true;
        if(node.getLeftChild() != null)
            savePrint(node.getLeftChild());
        if(node.getMiddleChild() != null)
            savePrint(node.getMiddleChild());
        if(node.getRightChild() != null)
            savePrint(node.getRightChild());
    }

    /**
     * Resets cursor to the root
     * Postcondition:
     * cursor references root of the tree
     */
    public void resetCursor(){
        cursor = root.getLeftChild();
    }

    /**
     * Moves the cursor to the indicated position
     * @param position
     * position to move cursor to
     * Precondition:
     * The child with the indicated position member variable exists as a direct child of the cursor
     * Postcondition:
     * cursor now points to the node at the indicated position
     * @exception
     * throws IllegalArgumentException if position is empty or null
     * throws NodeNotPresentException if node at indicated position
     */
    public void selectChild(String position){
        cursor = root;
        for(int i=0; i<cursor.getPosition().length(); i++){
            if(position.charAt(i) == '1')
                cursor = cursor.getLeftChild();
            else if(position.charAt(i) == '2')
                cursor = cursor.getMiddleChild();
            else if(position.charAt(i) == '3')
                cursor = cursor.getRightChild();
        }
    }

    /**
     * Adds a new node to the tree
     * @param position
     * position of where the new node will be added
     * @param option
     * the option of the new node
     * @param message
     * the message of the new node
     * Postcondition:
     * new node will be created and added to the left most slot available
     * @exception
     * throws IllegalArgumentException if String is either null or empty
     * throws TreeFullException if all three child spots are full
     */
    public void addChild(String position, String option, String message){
        StoryTreeNode newNode = new StoryTreeNode(position, option, message);
        int posLength = position.length();
        StoryTreeNode temp = root;
        for(int i=0; i<posLength-1; i+=2){
            if(position.charAt(i) == '1')
                temp = temp.getLeftChild();
            else if(position.charAt(i) == '2')
                temp = temp.getMiddleChild();
            else if(position.charAt(i) == '3')
                temp = temp.getRightChild();
        }
        if(position.charAt(posLength-1) == '1')
            temp.setLeftChild(newNode);
        else if(position.charAt(posLength-1) == '2')
            temp.setMiddleChild(newNode);
        else if(position.charAt(posLength-1) == '3')
            temp.setRightChild(newNode);
    }

    /**
     * Removes a node and its subtree
     * @param position
     * position of the node to be removed
     * Precondition:
     * The child with the indicated position member variable exists as a direct child of the cursor
     * Postcondition:
     * The indicated child and it's entire sub-tree have been removed from the tree
     * @return
     * the node removed from the tree
     * @exception
     * throws NodeNotPresentExcecption if node with indicated position was not found
     */
    public StoryTreeNode removeChild(String position){
        StoryTreeNode temp = root;
        StoryTreeNode remove = new StoryTreeNode();
        int num = position.length();
        for(int i=0; i<position.length()-1; i+=2){
            if(position.charAt(i) == '1')
                temp = temp.getLeftChild();
            else if(position.charAt(i) == '2')
                temp = temp.getMiddleChild();
            else if(position.charAt(i) == '3')
                temp = temp.getRightChild();
        }
        if(position.charAt(position.length()-1) == '1') {
            remove = temp.getLeftChild();
            temp.setLeftChild(temp.getMiddleChild());
            temp.setMiddleChild(temp.getRightChild());
            if(temp.getLeftChild() != null)
                reorder(temp.getLeftChild(), '1', num);
            if(temp.getMiddleChild() != null)
                reorder(temp.getMiddleChild(), '2', num);
        }
        else if(position.charAt(position.length()-1) == '2') {
            remove = temp.getMiddleChild();
            temp.setMiddleChild(temp.getRightChild());
            if(temp.getRightChild() != null)
                reorder(temp.getMiddleChild(), '2', num);
        }
        else if(position.charAt(position.length()-1) == '3') {
            remove = temp.getRightChild();
            temp.setRightChild(null);
        }
        return remove;
    }

    /**
     * Traverses through other children nodes to rename position to simulate a shift to the most left
     * @param node
     * node being renamed
     * @param index
     * the new position number needed to be changed to
     * @param num
     * length of the parent position
     * Postcondition:
     * all nodes are renamed to be shifted the left most posssible
     */
    public void reorder(StoryTreeNode node, char index, int num){
        StoryTreeNode temp = node;
        if(temp.getPosition().length() == num)
            temp.setPosition(temp.getPosition().substring(0,num-1) + index);
        else
            temp.setPosition(temp.getPosition().substring(0,num-1) + "-" + index + temp.getPosition().substring(num+1));
        if(temp.getLeftChild() != null)
            reorder(node.getLeftChild(), index, num);
        if(temp.getMiddleChild() != null)
            reorder(node.getMiddleChild(), index, num);
        if(temp.getRightChild() != null)
            reorder(node.getRightChild(), index, num);
    }

    /**
     * returns the cursor to the parent of cursor
     * Postcondition:
     * cursor now references its parent
     */
    public void returnToParent(){
        String position = cursor.getPosition();
        cursor = root;
        for(int i=0; i<cursor.getPosition().length()-21; i+=2){
            if(position.charAt(i) == '1')
                cursor = cursor.getLeftChild();
            else if(position.charAt(i) == '2')
                cursor = cursor.getMiddleChild();
            else if(position.charAt(i) == '3')
                cursor = cursor.getRightChild();
        }
    }

    /**
     * calculates the winning probability from current node
     * @return
     * the probability of winning in percentage
     */
    public double winProbability(){
        win = 0.0;
        count = 0.0;
        cursor.traverse();
        return win/count*100;
    }

    public GameState getState() { //getter method for the state of the game
        return state;
    }
    public String getCursorPosition(){ //getter method for the position of the cursor
        return cursor.getPosition();
    }
    public String getCursorMessage(){ //getter method for the message of the cursor
        return cursor.getMessage();
    }

    /**
     * @return
     * Returns an array of String pairs - {position, option} for each immediate child of the cursor
     */
    public String[][] getOptions(){
        String temp[][] = new String[2][3];
        temp[0][0] = cursor.getLeftChild().getPosition();
        temp[0][1] = cursor.getMiddleChild().getPosition();
        temp[0][2] = cursor.getRightChild().getPosition();
        temp[1][0] = cursor.getLeftChild().getOption();
        temp[1][1] = cursor.getMiddleChild().getOption();
        temp[1][2] = cursor.getRightChild().getOption();
        return temp;
    }
    public void setCursorMessage(String newMessage){ //setter method for message of cursor
        cursor.setMessage(newMessage);
    }
    public void setCursorOption(String newOption){ //setter method for option of cursor
        cursor.setOption(newOption);
    }
    public void setState(GameState state){ //setter for the GameState of the story
        this.state = state;
    }
}
